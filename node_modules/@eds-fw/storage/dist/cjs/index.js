"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayStorage = exports.Storage = void 0;
const utils_1 = require("@eds-fw/utils");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const DEFAULT_AUTOSAVE_INTERVAL = 60_000; //1 minute
class Storage extends Map {
    /** There can be no more than one Storage per file. If `true`, all instances with the same paths will be equal. */
    static oneFile_oneStorage = true;
    static #loadedStorages = {};
    #saving = false;
    path;
    /**
     * @param path **WARNING!** It is calculated from `process.cwd()`
     */
    constructor(path, autosave) {
        try {
            (0, fs_1.accessSync)(path);
        }
        catch (err) {
            const absolutePath = (0, path_1.resolve)(path);
            const dir = (0, path_1.dirname)(absolutePath);
            (0, fs_1.mkdirSync)(dir, { recursive: true });
            (0, fs_1.writeFileSync)(absolutePath, "{}", "utf8");
        }
        if (Storage.oneFile_oneStorage && path in Storage.#loadedStorages)
            return Storage.#loadedStorages[path];
        else {
            const entries = Object.entries(JSON.parse((0, fs_1.readFileSync)(path).toString() || "{}"));
            super(entries);
        }
        this.path = path;
        if (autosave)
            setInterval(() => this.save(), typeof autosave == "number" ? autosave : DEFAULT_AUTOSAVE_INTERVAL);
    }
    /**
     * @param path **WARNING!** It is calculated from `process.cwd()`
     */
    static create(...params) { return new this(...params); }
    hasValue(value) {
        for (const val of this.values())
            if ((0, utils_1.equal)(value, val))
                return true;
        return false;
    }
    getKey(value, single = false) {
        const result = [];
        for (const [k, v] of this.entries())
            if ((0, utils_1.equal)(value, v)) {
                result.push(k);
                if (single)
                    break;
            }
        return result;
    }
    filter(callbackfn) {
        const result = new Map();
        for (const [key, val] of this.entries())
            if (callbackfn(val, key, this))
                result.set(key, val);
        return result;
    }
    //====================================================
    async save() {
        if (this.#saving)
            return;
        this.#saving = true;
        await (0, promises_1.writeFile)(this.path, this.asJSON);
        this.#saving = false;
    }
    get asJSON() { return Storage.asJSON(this); }
    //====================================================
    [Symbol.toStringTag] = "Storage";
    static asJSON(map, pretty = true) {
        if (map.size == 0)
            return "{}";
        let entries = "";
        map.forEach((v, k) => {
            entries += (pretty ? ',\n\t' : ',') + `"${k}":${pretty ? ' ' : ''}${JSON.stringify(v)}`;
        });
        return '{' + entries.slice(1) + (pretty ? '\n}' : '}');
    }
}
exports.Storage = Storage;
exports.default = Storage;
/**
 * `Array`-based storage
 */
class ArrayStorage extends Array {
    /** There can be no more than one ArrayStorage per file. If `true`, all instances with the same paths will be equal. */
    static oneFile_oneStorage = true;
    static #loadedStorages = {};
    #saving = false;
    path;
    constructor() { super(); }
    /**
     * @param path **WARNING!** It is calculated from `process.cwd()`
     */
    static create(path, autosave) {
        const storage = new this();
        try {
            (0, fs_1.accessSync)(path);
        }
        catch (err) {
            const absolutePath = (0, path_1.resolve)(path);
            const dir = (0, path_1.dirname)(absolutePath);
            (0, fs_1.mkdirSync)(dir, { recursive: true });
            (0, fs_1.writeFileSync)(absolutePath, "[]", "utf8");
        }
        if (ArrayStorage.oneFile_oneStorage && path in ArrayStorage.#loadedStorages)
            return ArrayStorage.#loadedStorages[path];
        else {
            const entries = JSON.parse((0, fs_1.readFileSync)(path).toString() || "[]");
            storage.push(...entries);
        }
        storage.path = path;
        if (autosave)
            setInterval(() => storage.save(), typeof autosave == "number" ? autosave : DEFAULT_AUTOSAVE_INTERVAL);
        return storage;
    }
    //====================================================
    async save() {
        if (this.#saving)
            return;
        this.#saving = true;
        await (0, promises_1.writeFile)(this.path, this.asJSON);
        this.#saving = false;
    }
    get asJSON() { return ArrayStorage.asJSON(this); }
    //====================================================
    [Symbol.toStringTag] = "ArrayStorage";
    static asJSON(arr, pretty = true) {
        if (arr.length == 0)
            return "[]";
        let entries = "";
        arr.forEach(v => {
            entries += (pretty ? ',\n\t' : ',') + `${JSON.stringify(v)}`;
        });
        return '[' + entries.slice(1) + (pretty ? '\n]' : ']');
    }
}
exports.ArrayStorage = ArrayStorage;
